{{- define "header"}}
package {{FromTags "package"}}

import "{{FromTags "import"}}"
import "core:runtime"
import "core:mem"
{{end}}

{{define "enums"}}
    {{- /*gotype: karmem.org/cmd/karmem/kmparser.File*/ -}}
{{- range $root := .Enums}}
Enum{{$root.Data.Name}} :: enum {{ToType $root.Data.Type}} {
    {{- range $field := $root.Data.Fields}}
    {{$field.Data.Name}} = {{$field.Data.Value}},
    {{- end}}
}
{{end}}
{{end}}

{{define "enums_builder"}}
    {{- /*gotype: karmem.org/cmd/karmem/kmparser.File*/ -}}

{{end}}

{{define "struct"}}

EnumPacketIdentifier :: enum u64le {
{{- range $root := .Structs}}
    PacketIdentifier{{$root.Data.Name}} = {{$root.Data.ID}},
{{- end }}
}

    {{- /*gotype: karmem.org/cmd/karmem/kmparser.File*/ -}}
{{range $root := .Structs}}
{{$root.Data.Name}} :: struct {
{{- range $field := $root.Data.Fields }}
    {{ $field.Data.Name }}: {{ToType $field.Data.Type}},
{{- end }}
}

New{{$root.Data.Name}} :: proc() -> {{$root.Data.Name}} #no_bounds_check {
    return {{$root.Data.Name}} {}
}

{{$root.Data.Name}}Reset :: proc(x: ^{{$root.Data.Name}}) #no_bounds_check {
     // x.Read((*{{$root.Data.Name}}Viewer)(unsafe.Pointer(&_Null)), _NullReader)
}

{{$root.Data.Name}}WriteAsRoot :: proc(x: ^{{$root.Data.Name}}, writer: ^karmem.Writer) -> (uint, karmem.Error) #no_bounds_check {
    return {{$root.Data.Name}}Write(x, writer, 0)
}

{{$root.Data.Name}}Write ::proc(x: ^{{$root.Data.Name}}, writer: ^karmem.Writer, start: uint) -> (uint, karmem.Error) #no_bounds_check {
    offset := start
    size := u32({{$root.Data.Size.Total}})
    if offset == 0 {
        off, err := karmem.WriterAlloc(writer, size)
        if err != karmem.Error.ERR_NONE {
            return 0, err
        }
        offset = off
    }

    {{- if $root.Data.IsTable}}
    karmem.WriterWrite4At(writer, offset, u32({{$root.Data.Size.Content}}))
    {{- end}}

    {{- range $field := $root.Data.Fields }}
        {{- if not $field.Data.Type.IsInline}}
            {{- if $field.Data.Type.IsBasic}}
    __{{$field.Data.Name}}Size := u32({{$field.Data.Size.Allocation}})
            {{- else}}
    __{{$field.Data.Name}}Size := u32({{$field.Data.Size.Allocation}} * len(x.{{$field.Data.Name}}))
            {{- end}}
        {{- end }}
        {{- if $field.Data.Type.IsInline }}
    __{{$field.Data.Name}}Offset := offset+{{$field.Data.Offset}}
        {{- if $field.Data.Type.IsArray }}
    __{{$field.Data.Name}}Size := u32({{$field.Data.Size.Allocation}} * len(x.{{$field.Data.Name}}))
        {{- end }}
        {{- else }}
    __{{$field.Data.Name}}Offset, __{{$field.Data.Name}}Err := karmem.WriterAlloc(writer, __{{$field.Data.Name}}Size)
    if __{{$field.Data.Name}}Err != karmem.Error.ERR_NONE {
        return 0, __{{$field.Data.Name}}Err
    }
    karmem.WriterWrite4At(writer, offset+{{$field.Data.Offset}}, u32(__{{$field.Data.Name}}Offset))
        {{- if $field.Data.Type.IsSlice}}
    karmem.WriterWrite4At(writer, offset+{{$field.Data.Offset}} + 4, u32(__{{$field.Data.Name}}Size))
    karmem.WriterWrite4At(writer, offset+{{$field.Data.Offset}} + 4 + 4, {{$field.Data.Size.Allocation}})
        {{- end }}
        {{- end }}
        {{- if or $field.Data.Type.IsNative $field.Data.Type.IsEnum }}
            {{- if $field.Data.Type.IsInline}}
                {{- if $field.Data.Type.IsArray }}
    karmem.WriterWriteAt(writer, __{{$field.Data.Name}}Offset, rawptr(&x.{{$field.Data.Name}}), __{{$field.Data.Name}}Size)
                {{- else }}
                    {{- if eq $field.Data.Size.Allocation 1}}
    karmem.WriterWrite1At(writer, __{{$field.Data.Name}}Offset, (cast(^u8)&x.{{$field.Data.Name}})^)
                    {{- end}}
                    {{- if eq $field.Data.Size.Allocation 2}}
    karmem.WriterWrite2At(writer, __{{$field.Data.Name}}Offset, (cast(^u16)&x.{{$field.Data.Name}})^)
                    {{- end}}
                    {{- if eq $field.Data.Size.Allocation 4}}
    karmem.WriterWrite4At(writer, __{{$field.Data.Name}}Offset, (cast(^u32)&x.{{$field.Data.Name}})^)
                    {{- end}}
                    {{- if eq $field.Data.Size.Allocation 8}}
    karmem.WriterWrite8At(writer, __{{$field.Data.Name}}Offset, (cast(^u64)&x.{{$field.Data.Name}})^)
                    {{- end}}
                {{- end}}
            {{- else}}
                {{- if $field.Data.Type.IsSlice}}
                    {{- if $field.Data.Type.IsString }}
    if __{{$field.Data.Name}}Size > 0 {
        karmem.WriterWriteAt(writer, __{{$field.Data.Name}}Offset, rawptr((cast(^[^]u8)(&x.{{$field.Data.Name}}))^), __{{$field.Data.Name}}Size)
    }
                    {{- else}}
    if __{{$field.Data.Name}}Size > 0 {
        karmem.WriterWriteAt(writer, __{{$field.Data.Name}}Offset, rawptr(&x.{{$field.Data.Name}}[0]), __{{$field.Data.Name}}Size)
    }
                    {{- end}}
                {{- else}}
    karmem.WriterWriteAt(writer, __{{$field.Data.Name}}Offset, rawptr(&x.{{$field.Data.Name}}[0]), __{{$field.Data.Name}}Size)
                {{- end}}
            {{- end}}
        {{- else }}
            {{- if $field.Data.Type.IsBasic}}
    if _, err := {{ToPlainType $field.Data.Type}}Write(&x.{{$field.Data.Name}}, writer, __{{$field.Data.Name}}Offset); err != nil {
        return offset, err
    }
            {{- else}}
    for i := 0; i < len(x.{{$field.Data.Name}}); i += 1 {
        if _, err := {{ToPlainType $field.Data.Type}}Write(&x.{{$field.Data.Name}}[i], writer, __{{$field.Data.Name}}Offset); err != nil {
            return offset, err
        }
        __{{$field.Data.Name}}Offset += {{$field.Data.Size.Allocation}}
    }
            {{- end}}
        {{- end}}

    {{- end}}

    return offset, nil
}

{{$root.Data.Name}}ReadAsRoot :: proc(x: ^{{$root.Data.Name}}, reader: ^karmem.Reader) #no_bounds_check {
    {{$root.Data.Name}}Read(x, New{{$root.Data.Name}}Viewer(reader, 0), reader)
}

{{$root.Data.Name}}Read :: proc(x: ^{{$root.Data.Name}}, viewer: ^{{$root.Data.Name}}Viewer, reader: ^karmem.Reader) #no_bounds_check {
    {{- range $field := $root.Data.Fields }}
        {{- if $field.Data.Type.IsBasic}}
            {{- if $field.Data.Type.IsEnum}}
    x.{{$field.Data.Name}} = {{ToType $field.Data.Type}}({{$root.Data.Name}}Viewer{{$field.Data.Name}}(viewer))
            {{- else}}
                {{- if $field.Data.Type.IsNative}}
    x.{{$field.Data.Name}} = {{$root.Data.Name}}Viewer{{$field.Data.Name}}(viewer)
                {{- else}}
    {{ToPlainType $field.Data.Type}}Read(&x.{{$field.Data.Name}}, {{$root.Data.Name}}Viewer{{$field.Data.Name}}(viewer, {{- if not $field.Data.Type.IsInline}}reader{{- end}}), reader)
                {{- end}}
            {{- end}}
        {{- else}}
            {{- if $field.Data.Type.IsBasic}}
    {{ToPlainType $field.Data.Type}}Read(&x.{{$field.Data.Name}}, {{$root.Data.Name}}Viewer{{$field.Data.Name}}(viewer, reader), reader)
            {{- end}}
            {{- if $field.Data.Type.IsString}}
    __{{$field.Data.Name}}String := {{$root.Data.Name}}Viewer{{$field.Data.Name}}(viewer, reader)
    if x.{{$field.Data.Name}} != __{{$field.Data.Name}}String {
        if len(__{{$field.Data.Name}}String) > 0 {
            __{{$field.Data.Name}}StringCopy := make([dynamic]u8, len(__{{$field.Data.Name}}String), len(__{{$field.Data.Name}}String))
            runtime.mem_copy(rawptr(&__{{$field.Data.Name}}StringCopy[0]), rawptr((cast(^[^]u8)(&__{{$field.Data.Name}}String))^), len(__{{$field.Data.Name}}String))
            x.{{$field.Data.Name}} = (cast(^string)(&__{{$field.Data.Name}}StringCopy))^
        } else {
            x.{{$field.Data.Name}} = ""
        }
    }
    {{- else}}
        {{- if $field.Data.Type.IsSlice}}
    __{{$field.Data.Name}}Slice := {{$root.Data.Name}}Viewer{{$field.Data.Name}}(viewer, reader)
    __{{$field.Data.Name}}Len := len(__{{$field.Data.Name}}Slice)
    __{{$field.Data.Name}}Size := {{$field.Data.Size.Allocation}} * __{{$field.Data.Name}}Len
    if __{{$field.Data.Name}}Len > cap(x.{{$field.Data.Name}}) {
        __{{$field.Data.Name}}Target := cap(x.{{$field.Data.Name}}) * 2
        if __{{$field.Data.Name}}Target < __{{$field.Data.Name}}Len {
            __{{$field.Data.Name}}Target = __{{$field.Data.Name}}Len
        }
        __{{$field.Data.Name}}Realloc := make([dynamic]{{ToPlainType $field.Data.Type}}, __{{$field.Data.Name}}Len)
        for i := 0; i < len(x.{{$field.Data.Name}}); i += 1 {
            __{{$field.Data.Name}}Realloc[i] = x.{{$field.Data.Name}}[i]
        }
        delete(x.{{$field.Data.Name}})
        x.{{$field.Data.Name}} = __{{$field.Data.Name}}Realloc
    } else if __{{$field.Data.Name}}Len > len(x.{{$field.Data.Name}}) {
        (cast(^[3]int)(&x.{{$field.Data.Name}}))[1] = __{{$field.Data.Name}}Len
    }
        {{- else}}
    __{{$field.Data.Name}}Slice := {{$root.Data.Name}}Viewer{{$field.Data.Name}}(viewer)
    __{{$field.Data.Name}}Len := len(__{{$field.Data.Name}}Slice)
    __{{$field.Data.Name}}Size := {{$field.Data.Size.Allocation}} * {{$field.Data.Type.Length}}
        {{- end }}
        {{- if $field.Data.Type.IsNative}}
            {{- if $field.Data.Type.IsArray}}
    runtime.mem_copy(rawptr(&x.{{$field.Data.Name}}[0]), rawptr(&__{{$field.Data.Name}}Slice[0]), __{{$field.Data.Name}}Size)
            {{- else}}
    if __{{$field.Data.Name}}Len > 0 {
        runtime.mem_copy(rawptr(&x.{{$field.Data.Name}}[0]), rawptr(&__{{$field.Data.Name}}Slice[0]), __{{$field.Data.Name}}Size)
    }
            {{- end}}
        {{- else}}
    for i := 0; i < len(x.{{$field.Data.Name}}); i += 1 {
        if i >= __{{$field.Data.Name}}Len {
            {{ToPlainType $field.Data.Type}}Reset(&x.{{$field.Data.Name}}[i])
        } else {
            {{ToPlainType $field.Data.Type}}Read(&x.{{$field.Data.Name}}[i], &__{{$field.Data.Name}}Slice[i], reader)
        }
    }
        {{- end }}
    {{- end }}
        {{- end}}
    {{- end }}
}
{{- end }}
{{end}}



{{define "struct_builder"}}
    {{- /*gotype: karmem.org/cmd/karmem/kmparser.File*/ -}}
    {{- range $root := .Structs}}
{{$root.Data.Name}}Viewer :: struct {
    _data: [{{$root.Data.Size.Total}}]byte
}

New{{$root.Data.Name}}Viewer :: proc(reader: ^karmem.Reader, offset: u32) -> ^{{$root.Data.Name}}Viewer  #no_bounds_check {
    if karmem.ReaderIsValidOffset(reader, offset, {{$root.Data.Size.Minimum}}) == false {
        return nil
        // return (*{{$root.Data.Name}}Viewer)(unsafe.Pointer(&_Null))
    }
    v := cast(^{{$root.Data.Name}}Viewer)(&reader.memory[offset])
{{- if $root.Data.IsTable}}
    if karmem.ReaderIsValidOffset(reader, offset, {{$root.Data.Name}}ViewerSize(v)) == false {
        return nil
        // return (*{{$root.Data.Name}}Viewer)(unsafe.Pointer(&_Null))
    }
{{- end}}
    return v
}

{{$root.Data.Name}}ViewerSize :: proc(x: ^{{$root.Data.Name}}Viewer) -> u32 #no_bounds_check {
{{- if $root.Data.IsTable}}
    return ((^u32)(&x._data))^
{{- else}}
    return {{$root.Data.Size.Total}}
{{- end }}
}

{{- range $field := $root.Data.Fields }}
{{$root.Data.Name}}Viewer{{$field.Data.Name}} :: proc(x: ^{{$root.Data.Name}}Viewer, {{- if not $field.Data.Type.IsInline}}reader: ^karmem.Reader{{- end}}) -> {{ToTypeView $field.Data.Type}} #no_bounds_check {
    {{- if $root.Data.IsTable}}
    if {{$field.Data.Offset}} + {{$field.Data.Size.Field}} > {{$root.Data.Name}}ViewerSize(x) {
    {{- if or (and $field.Data.Type.IsBasic $field.Data.Type.IsNative) (or $field.Data.Type.IsString $field.Data.Type.IsEnum) }}
        {{- if $field.Data.Type.IsEnum}}
        return {{ToTypeView $field.Data.Type}}({{ToDefault $field.Data.Type}})
        {{- else }}
        return {{ToDefault $field.Data.Type}}
        {{- end }}
    {{- else}}
        {{- if or $field.Data.Type.IsSlice $field.Data.Type.IsArray}}
        return {{ToTypeView $field.Data.Type}}{}
        {{- else }}
        // return (*{{ToPlainType $field.Data.Type}}Viewer)(unsafe.Pointer(&_Null))
        {{- end }}
    {{- end}}
    }
    {{- end}}

    {{- if $field.Data.Type.IsInline}}
        {{- if not $field.Data.Type.IsArray}}
            {{- if or $field.Data.Type.IsNative $field.Data.Type.IsEnum }}
    return ((^{{ToTypeView $field.Data.Type}})(&x._data[{{$field.Data.Offset}}]))^
            {{- else}}
    return (({{ToTypeView $field.Data.Type}})(&x._data[{{$field.Data.Offset}}]))

            {{- end}}
        {{- else}}
    slice := [2]int{ 0, {{$field.Data.Type.Length}}}
    (cast(^rawptr)(&slice[0]))^ = ((^rawptr)(&x._data[{{$field.Data.Offset}}]))^

    return ((^{{ToTypeView $field.Data.Type}})(&slice))^
        {{- end}}
    {{- else }}
        offset := ((^u32)(&x._data[{{$field.Data.Offset}}]))^
        {{- if $field.Data.Type.IsSlice}}
            size := ((^u32)(&x._data[{{$field.Data.Offset}} + 4]))^
            if karmem.ReaderIsValidOffset(reader, offset, size) == false {
            {{- if $field.Data.Type.IsString }}
                return ""
            {{- else}}
                return {{ToTypeView $field.Data.Type}}{}
            {{- end}}
            }
            length := uint(size / {{$field.Data.Size.Allocation}})
            {{- if $field.Data.Type.IsLimited }}
                if length > {{$field.Data.Type.Length}} {
                    length = {{$field.Data.Type.Length}}
                }
            {{- end }}
            slice := [2]uint{0, length}
            (cast(^rawptr)(&slice[0]))^ = rawptr(&reader.memory[offset])
            return (cast(^{{ToTypeView $field.Data.Type}})(&slice))^
        {{- else}}
            return New{{ToType $field.Data.Type}}Viewer(reader, offset)
        {{- end}}
    {{- end}}
}
{{- end}}

    {{- end }}
{{end}}